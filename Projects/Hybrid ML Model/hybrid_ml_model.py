# -*- coding: utf-8 -*-
"""Hybrid ML model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kwPS7kAYNkq6H-iBV11dUk7r4_4q2Uwm

Hybrid machine learning models combine multiple algorithms to enhance predictive performance and robustness by leveraging their unique strengths. These models are particularly useful when a single algorithm cannot capture the complexity of the data, such as sequential patterns or broader trends. For example, combining LSTM for sequence learning with Linear Regression for trend analysis can improve results. The need for a hybrid approach arises when single models show poor performance based on metrics, as combining different models can address diverse data patterns effectively.
"""

import pandas as pd
data = pd.read_csv("./SAFCOM.csv")
data.head()

# converting date column to datetime type
data["Date"] = pd.to_datetime(data['Date'])
data.set_index('Date', inplace= True)
data.head()

data.columns

close = data[[' Close']]

close.head()

close.columns

"""## Choosing the Hybrid Models

The approach involves using LSTM (Long Short-Term Memory) and Linear Regression models to create a hybrid system. LSTM was selected for its ability to capture sequential dependencies and patterns in time-series data, making it well-suited for modeling stock price movements influenced by historical trends. Linear Regression, being a simple model, is used to capture linear relationships and long-term trends in the data. By combining these models, the aim is to balance LSTM's ability to model complex time-dependent patterns with Linear Regression’s focus on broader trends, resulting in a more accurate prediction system. The Close price data is scaled between 0 and 1 using MinMaxScaler to ensure compatibility with the LSTM model.

scale the Close price data between 0 and 1 using MinMaxScaler to ensure compatibility with the LSTM model
"""

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range= (0,1))
close[' Close'] = scaler.fit_transform(close[[' Close']])
close.head()

"""prepare the data for LSTM by creating sequences of a defined length (e.g., 60 days) to predict the next day’s price:"""

import numpy as np
def sequences(data, length= 60):
    X, y = [], []
    for i in range(len(data) - length):
        X.append(data[i:i+length])
        y.append(data[i+length])
    return np.array(X), np.array(y)

sequence_length = 60
X, y = sequences(close[' Close'].values, sequence_length)
X.shape

y.shape

"""split the sequences into training and test sets (e.g., 80% training, 20% testing):"""

train_size = int(len(X) * 0.8)
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

"""build a sequential LSTM model with layers to capture the temporal dependencies in the data:"""

!pip install tensorflow

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense


model = Sequential()
model.add(LSTM(50, return_sequences= True, input_shape= (X_train.shape[1], 1)))
model.add(LSTM(50))
model.add(Dense(1))

model.compile(optimizer= 'adam', loss= 'mean_squared_error')
model.fit(X_train, y_train, epochs= 20, batch_size= 32)

"""let’s train the second model. Start by generating lagged features for Linear Regression (e.g., using the past 3 days as predictors):"""

data = pd.DataFrame(close[' Close'])  # Reset `data` to avoid conflicts
data['Lag_1'] = data[' Close'].shift(1)
data['Lag_2'] = data[' Close'].shift(2)
data['Lag_3'] = data[' Close'].shift(3)
data = data.dropna()

X_lin = data[['Lag_1', 'Lag_2', 'Lag_3']]
y_lin = data[' Close']
X_train_lin, X_test_lin = X_lin[:train_size], X_lin[train_size:]
y_train_lin, y_test_lin = y_lin[:train_size], y_lin[train_size:]

from sklearn.linear_model import LinearRegression
lin_model = LinearRegression()
lin_model.fit(X_train_lin, y_train_lin)

""" how to make predictions using LSTM on the test set and inverse transform the scaled predictions"""

X_test_lstm = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)
lstm_predictions = model.predict(X_test_lstm)
lstm_predictions = scaler.inverse_transform(lstm_predictions)

lstm_predictions

lstm_predictions.shape

lin_predictions = lin_model.predict(X_test_lin)
lin_predictions = scaler.inverse_transform(lin_predictions.reshape(-1, 1))

lin_predictions.shape

lin_predictions

"""use a weighted average to create hybrid predictions:"""

min_length = min(len(lstm_predictions), len(lin_predictions))

# Truncate both prediction arrays to the minimum length
lstm_predictions_aligned = lstm_predictions[:min_length]
lin_predictions_aligned = lin_predictions[:min_length]

lstm_predictions_aligned

lin_predictions_aligned

hybrid_predictions = (0.7 * lstm_predictions_aligned) + (0.3 * lin_predictions_aligned)

hybrid_predictions

"""Predicting using the Hybrid Model

make predictions for the next 10 days using our hybrid model
"""

# Making prediction with LSTM
lstm_future = []
last_sequence = X_test[-1].reshape(1, sequence_length, -1)
for _ in range(10):
    prediction = model.predict(last_sequence)[0,0]
    lstm_future.append(prediction)
    prediction_reshaped =np.array([[prediction]]).reshape(1, 1, 1)
    last_sequence= np.append(last_sequence[:, 1:, :], prediction_reshaped, axis=1)

lstm_future = scaler.inverse_transform(np.array(lstm_future).reshape(-1, 1))
lstm_future

# Next 10 Days using Linear Regression
recent = close[' Close'].values[-3:]
lin_future_pred = []
for _ in range(10):
    lin_pred = lin_model.predict(recent.reshape(1, -1))
    lin_future_pred.append(lin_pred)
    recent = np.append(recent[1:], lin_pred)

lin_future_pred = scaler.inverse_transform(np.array(lin_future_pred).reshape(-1, 1))
lin_future_pred

hybrid_future_pred = (0.7 * lstm_future) + (0.3 * lin_future_pred)
hybrid_future_pred

"""create the final DataFrame to look at the predictions"""

future = pd.date_range(start=close.index[-1] + pd.Timedelta(days=1), periods=10)
pred_df = pd.DataFrame({
    'Date': future,
    'LSTM': lstm_future.flatten(),
    'Linear Regression': lin_future_pred.flatten(),
    'Hybrid': hybrid_future_pred.flatten()
    })
pred_df.set_index('Date', inplace= True)
pred_df